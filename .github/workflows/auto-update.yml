# Auto Update Workflow
# Automated dependency updates via PR to staging branch
#
# Triggers:
#   - Schedule (weekly): Check dependencies ‚Üí Create PR with updates
#   - Manual dispatch: check-only or update mode
#
# Flow:
#   1. Check for dependency updates
#   2. Apply updates and run tests
#   3. Create PR to stage branch
#   4. If AUTO_MERGE_UPDATES is true: wait for checks, merge PR
#      (release workflow triggers automatically on push to stage)
#   5. If AUTO_MERGE_UPDATES is false: leave PR for manual review
#
# Reusable actions (copy to other Go projects):
#   - _go-setup: Go environment with caching
#   - _go-test: Run Go tests
#   - _goupdate: Dependency check and update
#   - _gh-pr: Create PRs with auto-merge
#
# Configuration (modify in env section below):
#   - GO_VERSION: Go version to use
#   - UPDATE_BRANCH_NAME: Branch name for dependency updates
#   - UPDATE_TARGET_BRANCH: Branch to merge updates into (stage)
#   - AUTO_MERGE_UPDATES: Enable auto-merge for update PRs
#   - DELETE_BRANCH_ON_MERGE: Delete update branch after merge
#   - PR_TITLE: PR title template (use {date} and {type} placeholders)
#   - COMMIT_MESSAGE: Commit message template
#   - TEST_COMMAND: Custom test command
#   - EXCLUDE_PACKAGES: Packages to skip updating

name: Auto Update

on:
  # Weekly check on Monday at 00:00 UTC
  schedule:
    - cron: '0 0 * * 1'

  # Manual trigger with multiple modes
  workflow_dispatch:
    inputs:
      mode:
        description: 'Operation mode'
        required: true
        default: 'update'
        type: choice
        options:
          - check-only   # Just check for updates, no changes
          - update       # Check + apply updates + create PR
      update-type:
        description: 'Dependency update type'
        required: false
        default: 'minor'
        type: choice
        options:
          - none
          - patch
          - minor
          - all

# Prevent concurrent runs on same branch
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

# ============================================================================
# CONFIGURATION - Modify for your project
# ============================================================================
env:
  GO_VERSION: '1.24'
  UPDATE_BRANCH_NAME: 'goupdate/auto-update-minor'
  UPDATE_TARGET_BRANCH: 'stage-updates'
  AUTO_MERGE_UPDATES: 'true'
  DELETE_BRANCH_ON_MERGE: 'true'
  # PR title template - use {date} for current date, {type} for update type (minor/patch/all)
  PR_TITLE: 'GoUpdate: Auto update - {type} ({date})'
  # Commit message template - supports {date} and {type} placeholders
  COMMIT_MESSAGE: 'GoUpdate: Auto update - {type} ({date})'
  TEST_COMMAND: 'echo "No custom test command specified"'
  EXCLUDE_PACKAGES: ''

permissions:
  contents: write
  pull-requests: write
  checks: read

jobs:
  # ============================================================================
  # Prepare - Determine what actions to take based on trigger
  # ============================================================================
  prepare:
    name: Prepare
    runs-on: ubuntu-latest
    timeout-minutes: 2
    outputs:
      run-dependency-check: ${{ steps.config.outputs.run_dependency_check }}
      run-updates: ${{ steps.config.outputs.run_updates }}
      check-only: ${{ steps.config.outputs.check_only }}
      update-type: ${{ steps.config.outputs.update_type }}
      auto-merge-updates: ${{ steps.config.outputs.auto_merge_updates }}

    steps:
      - name: Validate GitHub App credentials
        env:
          HAS_APP_ID: ${{ secrets.GOUPDATE_APP_ID != '' }}
          HAS_APP_PRIVATE_KEY: ${{ secrets.GOUPDATE_APP_PRIVATE_KEY != '' }}
        run: |
          if [ "$HAS_APP_ID" != "true" ] || [ "$HAS_APP_PRIVATE_KEY" != "true" ]; then
            echo "‚ùå ERROR: GitHub App credentials required for auto-update workflow"
            echo ""
            echo "The auto-update workflow requires a GitHub App to:"
            echo "  ‚Ä¢ Trigger PR workflows (tests, lints) on created PRs"
            echo "  ‚Ä¢ Access PR check status via REST API"
            echo "  ‚Ä¢ Merge PRs after checks pass"
            echo ""
            echo "Benefits of GitHub App authentication:"
            echo "  ‚Ä¢ Not tied to any user account"
            echo "  ‚Ä¢ Works across org repos with simple installation"
            echo "  ‚Ä¢ Higher API rate limits (5000/hr vs 1000/hr)"
            echo "  ‚Ä¢ Short-lived tokens (more secure)"
            echo "  ‚Ä¢ Fine-grained permissions"
            echo ""
            echo "üìñ Setup Instructions:"
            echo "   See README.md for detailed setup:"
            echo "   https://github.com/${{ github.repository }}#github-app-setup-required-for-auto-update"
            echo ""
            echo "Quick Setup:"
            echo "   1. Create GitHub App named 'GoUpdate-<YourOrg>' at: https://github.com/settings/apps/new"
            echo "   2. Set permissions: Checks (Read), Contents (Read/Write), Pull requests (Read/Write), Workflows (Read/Write)"
            echo "   3. Install app on your repository/organization"
            echo "   4. Generate private key and note the App ID"
            echo "   5. Add secrets: GOUPDATE_APP_ID and GOUPDATE_APP_PRIVATE_KEY"
            echo ""
            echo "Missing secrets:"
            [ "$HAS_APP_ID" != "true" ] && echo "   - GOUPDATE_APP_ID"
            [ "$HAS_APP_PRIVATE_KEY" != "true" ] && echo "   - GOUPDATE_APP_PRIVATE_KEY"
            echo ""
            exit 1
          fi
          echo "‚úÖ GitHub App credentials configured"

      - name: Determine actions
        id: config
        env:
          AUTO_MERGE: ${{ env.AUTO_MERGE_UPDATES }}
        run: |
          EVENT="${{ github.event_name }}"
          MODE="${{ github.event.inputs.mode }}"
          UPDATE_TYPE="${{ github.event.inputs.update-type }}"

          echo "Event: $EVENT, Mode: $MODE, Update-Type: $UPDATE_TYPE, Auto-Merge: $AUTO_MERGE"

          # Pass through auto-merge setting
          echo "auto_merge_updates=$AUTO_MERGE" >> $GITHUB_OUTPUT

          case "$EVENT" in
            schedule)
              echo "run_dependency_check=true" >> $GITHUB_OUTPUT
              echo "run_updates=true" >> $GITHUB_OUTPUT
              echo "check_only=false" >> $GITHUB_OUTPUT
              echo "update_type=minor" >> $GITHUB_OUTPUT
              ;;
            workflow_dispatch)
              case "$MODE" in
                check-only)
                  echo "run_dependency_check=true" >> $GITHUB_OUTPUT
                  echo "run_updates=false" >> $GITHUB_OUTPUT
                  echo "check_only=true" >> $GITHUB_OUTPUT
                  echo "update_type=${UPDATE_TYPE:-minor}" >> $GITHUB_OUTPUT
                  ;;
                update)
                  echo "run_dependency_check=true" >> $GITHUB_OUTPUT
                  echo "run_updates=true" >> $GITHUB_OUTPUT
                  echo "check_only=false" >> $GITHUB_OUTPUT
                  echo "update_type=${UPDATE_TYPE:-minor}" >> $GITHUB_OUTPUT
                  ;;
                *)
                  echo "run_dependency_check=true" >> $GITHUB_OUTPUT
                  echo "run_updates=true" >> $GITHUB_OUTPUT
                  echo "check_only=false" >> $GITHUB_OUTPUT
                  echo "update_type=${UPDATE_TYPE:-minor}" >> $GITHUB_OUTPUT
                  ;;
              esac
              ;;
          esac

  # ============================================================================
  # Check for dependency updates
  # ============================================================================
  check-updates:
    name: Check Updates
    needs: prepare
    if: needs.prepare.outputs.run-dependency-check == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      has-updates: ${{ steps.goupdate.outputs.has-updates }}
      has-major-only: ${{ steps.goupdate.outputs.has-major-only }}
      summary: ${{ steps.goupdate.outputs.summary }}
      major-packages: ${{ steps.goupdate.outputs.major-packages }}
      outdated-output: ${{ steps.goupdate.outputs.outdated-output }}

    steps:
      - name: Checkout main first
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0

      - name: Ensure target branch exists
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TARGET_BRANCH: ${{ env.UPDATE_TARGET_BRANCH }}
        run: |
          # Configure git for potential push
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Check if target branch exists on remote
          if ! git ls-remote --heads origin "$TARGET_BRANCH" | grep -q "$TARGET_BRANCH"; then
            echo "Branch '$TARGET_BRANCH' does not exist. Creating from main..."
            git checkout -b "$TARGET_BRANCH"
            git push -u origin "$TARGET_BRANCH"
            echo "Created branch '$TARGET_BRANCH' from main"
          else
            echo "Branch '$TARGET_BRANCH' already exists"
            git fetch origin "$TARGET_BRANCH"
            git checkout "$TARGET_BRANCH"
          fi

      - name: Setup Go
        uses: ./.github/actions/_go-setup
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Check for updates
        id: goupdate
        uses: ./.github/actions/_goupdate
        with:
          mode: 'check'
          exclude-packages: ${{ env.EXCLUDE_PACKAGES }}

  # ============================================================================
  # Apply updates and create PR
  # ============================================================================
  apply-updates:
    name: Apply Updates
    needs: [prepare, check-updates]
    if: |
      needs.prepare.outputs.run-updates == 'true' &&
      needs.check-updates.outputs.has-updates == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      updated-count: ${{ steps.goupdate.outputs.updated-count }}
      has-changes: ${{ steps.goupdate.outputs.has-changes }}
      updated-packages: ${{ steps.goupdate.outputs.updated-packages }}
      update-output: ${{ steps.goupdate.outputs.update-output }}
      pr-url: ${{ steps.pr.outputs.pr-url }}
      pr-number: ${{ steps.pr.outputs.pr-number }}

    steps:
      - name: Checkout main first
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0

      - name: Ensure target branch exists
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TARGET_BRANCH: ${{ env.UPDATE_TARGET_BRANCH }}
        run: |
          # Configure git for potential push
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Check if target branch exists on remote
          if ! git ls-remote --heads origin "$TARGET_BRANCH" | grep -q "$TARGET_BRANCH"; then
            echo "Branch '$TARGET_BRANCH' does not exist. Creating from main..."
            git checkout -b "$TARGET_BRANCH"
            git push -u origin "$TARGET_BRANCH"
            echo "Created branch '$TARGET_BRANCH' from main"
          else
            echo "Branch '$TARGET_BRANCH' already exists"
            git fetch origin "$TARGET_BRANCH"
            git checkout "$TARGET_BRANCH"
          fi

      - name: Setup Go
        uses: ./.github/actions/_go-setup
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Create update branch
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Delete branch if it exists
          git push origin --delete "${{ env.UPDATE_BRANCH_NAME }}" 2>/dev/null || true

          # Create fresh branch
          git checkout -b "${{ env.UPDATE_BRANCH_NAME }}"

      - name: Apply updates with testing
        id: goupdate
        uses: ./.github/actions/_goupdate
        with:
          mode: 'update'
          update-type: ${{ needs.prepare.outputs.update-type }}
          test-command: ${{ env.TEST_COMMAND }}
          fail-on-major-only: 'true'
          exclude-packages: ${{ env.EXCLUDE_PACKAGES }}

      - name: Generate messages
        id: messages
        if: steps.goupdate.outputs.has-changes == 'true'
        env:
          PR_TITLE_TEMPLATE: ${{ env.PR_TITLE }}
          COMMIT_MSG_TEMPLATE: ${{ env.COMMIT_MESSAGE }}
          UPDATE_TYPE: ${{ needs.prepare.outputs.update-type }}
        run: |
          DATE=$(date -u +%Y-%m-%d)
          # Capitalize first letter of update type
          TYPE=$(echo "$UPDATE_TYPE" | sed 's/\b\(.\)/\u\1/')

          # Generate PR title
          TITLE=$(echo "$PR_TITLE_TEMPLATE" | sed "s/{date}/$DATE/g" | sed "s/{type}/$TYPE/g")
          echo "pr_title=$TITLE" >> $GITHUB_OUTPUT

          # Generate commit message
          COMMIT_MSG=$(echo "$COMMIT_MSG_TEMPLATE" | sed "s/{date}/$DATE/g" | sed "s/{type}/$TYPE/g")
          echo "commit_msg=$COMMIT_MSG" >> $GITHUB_OUTPUT

      - name: Commit and push changes
        if: steps.goupdate.outputs.has-changes == 'true'
        env:
          UPDATED_PKGS: ${{ steps.goupdate.outputs.updated-packages }}
          COMMIT_MSG: ${{ steps.messages.outputs.commit_msg }}
        run: |
          # Convert space-separated package list to bullet points
          FORMATTED_PKGS=$(echo "$UPDATED_PKGS" | tr ' ' '\n' | sed '/^$/d' | sed 's/^/- /')

          git add go.mod go.sum
          git commit -m "$(cat <<EOF
          $COMMIT_MSG

          Updated packages:
          $FORMATTED_PKGS
          EOF
          )"
          git push -u origin "${{ env.UPDATE_BRANCH_NAME }}"

      - name: Generate GitHub App token
        id: app-token
        if: steps.goupdate.outputs.has-changes == 'true'
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.GOUPDATE_APP_ID }}
          private-key: ${{ secrets.GOUPDATE_APP_PRIVATE_KEY }}

      - name: Format PR body
        id: pr-body
        if: steps.goupdate.outputs.has-changes == 'true'
        env:
          CHECK_OUTPUT: ${{ needs.check-updates.outputs.outdated-output }}
          UPDATE_OUTPUT: ${{ steps.goupdate.outputs.update-output }}
        run: |
          {
            echo "body<<PR_BODY_EOF_7e3c1a"
            echo "## Automated Dependency Update"
            echo ""
            echo "This PR was automatically created by the dependency update workflow."
            echo ""
            echo "### Check Updates"
            echo ""
            echo '```'
            echo "$CHECK_OUTPUT"
            echo '```'
            echo ""
            echo "### Apply Updates"
            echo ""
            echo '```'
            echo "$UPDATE_OUTPUT"
            echo '```'
            echo ""
            echo "---"
            echo "*Created by [GoUpdate](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})*"
            echo "PR_BODY_EOF_7e3c1a"
          } >> $GITHUB_OUTPUT

      - name: Create Pull Request
        id: pr
        if: steps.goupdate.outputs.has-changes == 'true'
        uses: ./.github/actions/_gh-pr
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          title: ${{ steps.messages.outputs.pr_title }}
          body: ${{ steps.pr-body.outputs.body }}
          base: ${{ env.UPDATE_TARGET_BRANCH }}
          head: ${{ env.UPDATE_BRANCH_NAME }}
          # Don't use GitHub's native auto-merge - it merges immediately if no branch protection
          # Instead, the merge-pr job waits for checks to pass and merges explicitly
          auto-merge: 'false'
          merge-method: 'squash'
          delete-branch: 'false'

  # ============================================================================
  # Wait for PR checks and merge
  # ============================================================================
  # This job waits for PR checks to pass then merges the PR.
  # The release workflow triggers automatically on push to stage branch.
  merge-pr:
    name: Merge PR
    needs: [prepare, apply-updates]
    if: |
      needs.prepare.outputs.auto-merge-updates == 'true' &&
      needs.apply-updates.outputs.pr-number != '' &&
      needs.apply-updates.outputs.has-changes == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      merged: ${{ steps.wait-merge.outputs.merged }}
      checks-passed: ${{ steps.wait-merge.outputs.checks_passed }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Generate GitHub App token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.GOUPDATE_APP_ID }}
          private-key: ${{ secrets.GOUPDATE_APP_PRIVATE_KEY }}

      - name: Wait for PR checks and merge
        id: wait-merge
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
          PR_NUMBER: ${{ needs.apply-updates.outputs.pr-number }}
          REPO: ${{ github.repository }}
        run: |
          echo "Waiting for PR #$PR_NUMBER checks to pass before merging..."
          echo ""
          echo "This workflow waits for all CI checks to complete before merging."
          echo "This ensures PRs are never merged while checks are still running."
          echo ""
          echo "Using GitHub App token for authentication"
          echo ""

          # Poll for PR status (max ~7.5 minutes with 30s intervals)
          MAX_ATTEMPTS=15
          ATTEMPT=0
          CHECKS_COMPLETE=false

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
            echo "Checking PR status (attempt $ATTEMPT/$MAX_ATTEMPTS)..."
            echo ""

            # Get PR state using REST API
            echo "Fetching PR #$PR_NUMBER data..."
            if ! PR_DATA=$(gh api "repos/$REPO/pulls/$PR_NUMBER" 2>&1); then
              echo ""
              echo "‚ùå Failed to fetch PR data: $PR_DATA"
              echo "Retrying in 30 seconds..."
              sleep 30
              continue
            fi

            STATE=$(echo "$PR_DATA" | jq -r '.state')
            MERGED=$(echo "$PR_DATA" | jq -r '.merged')
            HEAD_SHA=$(echo "$PR_DATA" | jq -r '.head.sha')

            echo "PR state: $STATE, merged: $MERGED, head SHA: ${HEAD_SHA:0:7}"

            # Check if already merged
            if [ "$MERGED" = "true" ]; then
              echo "‚úÖ PR #$PR_NUMBER has been merged!"
              echo "merged=true" >> $GITHUB_OUTPUT
              echo "checks_passed=true" >> $GITHUB_OUTPUT
              exit 0
            fi

            # Check if closed without merging
            if [ "$STATE" = "closed" ]; then
              echo "‚ùå PR #$PR_NUMBER was closed without merging"
              echo "merged=false" >> $GITHUB_OUTPUT
              echo "checks_passed=false" >> $GITHUB_OUTPUT
              exit 1
            fi

            # Check status of CI checks using REST API for check-runs
            if [ "$CHECKS_COMPLETE" = "false" ]; then
              echo ""
              echo "Fetching check runs for commit ${HEAD_SHA:0:7}..."
              if ! CHECKS_JSON=$(gh api "repos/$REPO/commits/$HEAD_SHA/check-runs" 2>&1); then
                echo ""
                echo "‚ùå Failed to fetch check runs: $CHECKS_JSON"
                echo "Retrying in 30 seconds..."
                sleep 30
                continue
              fi

              if echo "$CHECKS_JSON" | jq -e '.check_runs' > /dev/null 2>&1; then
                TOTAL_CHECKS=$(echo "$CHECKS_JSON" | jq '.total_count')
                PENDING=$(echo "$CHECKS_JSON" | jq '[.check_runs[] | select(.status != "completed")] | length')
                SUCCESSFUL=$(echo "$CHECKS_JSON" | jq '[.check_runs[] | select(.status == "completed" and (.conclusion == "success" or .conclusion == "skipped" or .conclusion == "neutral"))] | length')
                FAILED=$(echo "$CHECKS_JSON" | jq '[.check_runs[] | select(.status == "completed" and (.conclusion == "failure" or .conclusion == "cancelled" or .conclusion == "timed_out" or .conclusion == "startup_failure"))] | length')

                echo "Check runs: $TOTAL_CHECKS total, $PENDING pending, $SUCCESSFUL successful, $FAILED failed"

                # If any check failed, fail the workflow
                if [ "$FAILED" -gt 0 ]; then
                  echo ""
                  echo "‚ùå PR checks failed! Auto-merge will not proceed."
                  echo ""
                  echo "Failed checks:"
                  echo "$CHECKS_JSON" | jq -r '.check_runs[] | select(.status == "completed" and (.conclusion == "failure" or .conclusion == "cancelled" or .conclusion == "timed_out" or .conclusion == "startup_failure")) | "  - \(.name): \(.conclusion)"'
                  echo ""
                  echo "merged=false" >> $GITHUB_OUTPUT
                  echo "checks_passed=false" >> $GITHUB_OUTPUT
                  exit 1
                fi

                # If all checks completed successfully (none pending)
                if [ "$PENDING" -eq 0 ] && [ "$TOTAL_CHECKS" -gt 0 ]; then
                  echo ""
                  echo "‚úÖ All PR checks passed!"
                  CHECKS_COMPLETE=true
                  echo "checks_passed=true" >> $GITHUB_OUTPUT

                  echo "Attempting to merge PR #$PR_NUMBER..."
                  MERGE_OUTPUT=$(gh pr merge "$PR_NUMBER" --squash --delete-branch 2>&1)
                  MERGE_EXIT_CODE=$?
                  if [ $MERGE_EXIT_CODE -eq 0 ]; then
                    echo "‚úÖ PR #$PR_NUMBER merged successfully!"
                    echo "merged=true" >> $GITHUB_OUTPUT
                    exit 0
                  else
                    echo "Merge command returned exit code $MERGE_EXIT_CODE"
                    echo "Output: $MERGE_OUTPUT"
                    echo "Waiting for GitHub to complete merge..."
                    # Continue polling to confirm merge completed
                  fi
                elif [ "$TOTAL_CHECKS" -eq 0 ]; then
                  # No checks found, proceed with merge
                  echo ""
                  echo "No CI checks configured, proceeding with merge..."
                  CHECKS_COMPLETE=true
                  echo "checks_passed=true" >> $GITHUB_OUTPUT

                  echo "Attempting to merge PR #$PR_NUMBER..."
                  MERGE_OUTPUT=$(gh pr merge "$PR_NUMBER" --squash --delete-branch 2>&1)
                  MERGE_EXIT_CODE=$?
                  if [ $MERGE_EXIT_CODE -eq 0 ]; then
                    echo "‚úÖ PR #$PR_NUMBER merged successfully!"
                    echo "merged=true" >> $GITHUB_OUTPUT
                    exit 0
                  else
                    echo "Merge failed with exit code $MERGE_EXIT_CODE: $MERGE_OUTPUT"
                  fi
                else
                  echo "Waiting for $PENDING checks to complete..."
                fi
              else
                echo ""
                echo "‚ùå Failed to parse check runs response"
                echo "Raw response (first 50 lines):"
                echo "---"
                echo "$CHECKS_JSON" | head -50
                echo "---"
                echo ""
                echo "Retrying..."
              fi
            fi

            # Wait 30 seconds before next check
            sleep 30
          done

          echo ""
          echo "‚ùå Timeout waiting for PR to merge (~7.5 minutes)"
          echo "merged=false" >> $GITHUB_OUTPUT
          echo "checks_passed=false" >> $GITHUB_OUTPUT
          exit 1

  # ============================================================================
  # Summary
  # ============================================================================
  summary:
    name: Summary
    needs: [prepare, check-updates, apply-updates, merge-pr]
    if: always()
    runs-on: ubuntu-latest
    timeout-minutes: 5

    steps:
      - name: Generate summary
        env:
          EVENT: ${{ github.event_name }}
          MODE: ${{ github.event.inputs.mode }}
          HAS_UPDATES: ${{ needs.check-updates.outputs.has-updates }}
          OUTDATED_OUTPUT: ${{ needs.check-updates.outputs.outdated-output }}
          UPDATE_OUTPUT: ${{ needs.apply-updates.outputs.update-output }}
          UPDATED_COUNT: ${{ needs.apply-updates.outputs.updated-count }}
          PR_URL: ${{ needs.apply-updates.outputs.pr-url }}
          PR_NUMBER: ${{ needs.apply-updates.outputs.pr-number }}
          CHECK_RESULT: ${{ needs.check-updates.result }}
          APPLY_RESULT: ${{ needs.apply-updates.result }}
          MERGE_RESULT: ${{ needs.merge-pr.result }}
          PR_MERGED: ${{ needs.merge-pr.outputs.merged }}
          AUTO_MERGE_ENABLED: ${{ needs.prepare.outputs.auto-merge-updates }}
        run: |
          echo "## üîÑ Auto Update Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Trigger:** $EVENT" >> $GITHUB_STEP_SUMMARY
          if [ -n "$MODE" ]; then
            echo "**Mode:** $MODE" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY

          # PR info if created
          if [ -n "$PR_URL" ]; then
            echo "### üìã Pull Request" >> $GITHUB_STEP_SUMMARY
            echo "**PR:** [#$PR_NUMBER]($PR_URL)" >> $GITHUB_STEP_SUMMARY
            if [ "$AUTO_MERGE_ENABLED" = "true" ]; then
              if [ "$PR_MERGED" = "true" ]; then
                echo "**Status:** ‚úÖ Merged (release workflow triggers automatically)" >> $GITHUB_STEP_SUMMARY
              fi
            else
              echo "**Status:** üìù Awaiting manual review" >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          # Show Check Updates output
          if [ "$CHECK_RESULT" = "success" ] && [ -n "$OUTDATED_OUTPUT" ]; then
            echo "### Check Updates" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            echo "$OUTDATED_OUTPUT" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          # Show Apply Updates output
          if [ "$APPLY_RESULT" = "success" ] && [ -n "$UPDATE_OUTPUT" ]; then
            echo "### Apply Updates" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            echo "$UPDATE_OUTPUT" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          fi

          # What happens next - show only when PR was merged
          if [ "$PR_MERGED" = "true" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### üìù What Happens Next" >> $GITHUB_STEP_SUMMARY
            echo "The PR was merged to \`stage-updates\`. A prerelease will be created for testing." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "When ready for stable release:" >> $GITHUB_STEP_SUMMARY
            echo "1. Merge \`stage-updates\` ‚Üí \`main\`" >> $GITHUB_STEP_SUMMARY
            echo "2. Create a release using one of these methods:" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Option A: Command Line**" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
            echo "git tag v1.2.3 && git push origin v1.2.3" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Option B: GitHub UI**" >> $GITHUB_STEP_SUMMARY
            echo "1. Go to **Releases** ‚Üí **Create a new release**" >> $GITHUB_STEP_SUMMARY
            echo "2. Click **Choose a tag** ‚Üí type version (e.g., \`v1.2.3\`) ‚Üí **Create new tag**" >> $GITHUB_STEP_SUMMARY
            echo "3. Set **Target** to \`main\` and check **Set as the latest release**" >> $GITHUB_STEP_SUMMARY
            echo "4. Click **Publish release**" >> $GITHUB_STEP_SUMMARY
          fi
