# Goupdate Update Action
# Applies dependency updates for any supported package manager

name: 'Goupdate Update'
description: 'Apply dependency updates'

inputs:
  working-directory:
    description: 'Working directory containing dependency files'
    required: false
    default: '.'
  rule:
    description: 'Package manager rule to use (e.g., composer, npm, mod)'
    required: true
  update-type:
    description: 'Type of updates: none (use constraints), patch, minor, or all (includes major)'
    required: false
    default: 'minor'
  exclude-packages:
    description: 'Packages to skip (comma-separated)'
    required: false
    default: ''
  system-test-mode:
    description: 'System test run mode: after_each, after_all, or none'
    required: false
    default: ''
  verbose:
    description: 'Enable verbose output'
    required: false
    default: 'false'

outputs:
  updated:
    description: 'Whether any packages were updated'
    value: ${{ steps.update.outputs.updated }}
  has-changes:
    description: 'Whether dependency files were modified'
    value: ${{ steps.update.outputs.updated }}
  updated-packages:
    description: 'Space-separated list of updated packages'
    value: ${{ steps.update.outputs.updated_packages }}
  updated-count:
    description: 'Number of packages updated'
    value: ${{ steps.update.outputs.updated_count }}
  update-output:
    description: 'Raw output from goupdate update command'
    value: ${{ steps.update.outputs.update_output }}
  exit-code:
    description: 'Exit code from goupdate update command'
    value: ${{ steps.update.outputs.exit_code }}

runs:
  using: 'composite'
  steps:
    - name: Apply updates
      id: update
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      env:
        RULE: ${{ inputs.rule }}
        UPDATE_TYPE: ${{ inputs.update-type }}
        EXCLUDE: ${{ inputs.exclude-packages }}
        SYSTEM_TEST_MODE: ${{ inputs.system-test-mode }}
        VERBOSE: ${{ inputs.verbose }}
      run: |
        # Build update type flag
        UPDATE_FLAG=""
        case "$UPDATE_TYPE" in
          patch) UPDATE_FLAG="--patch" ;;
          minor) UPDATE_FLAG="--minor" ;;
          all)   UPDATE_FLAG="--all" ;;
          none)  UPDATE_FLAG="" ;;
        esac

        # Build exclude flag
        EXCLUDE_FLAG=""
        if [[ -n "$EXCLUDE" ]]; then
          EXCLUDE_FLAG="-e $EXCLUDE"
        fi

        # Build system test flag
        TEST_FLAG=""
        if [[ -n "$SYSTEM_TEST_MODE" ]]; then
          TEST_FLAG="--system-test-mode=$SYSTEM_TEST_MODE"
        fi

        # Build verbose flag
        VERBOSE_FLAG=""
        if [[ "$VERBOSE" == "true" ]]; then
          VERBOSE_FLAG="-v"
        fi

        # Run update with continue-on-fail to see all errors
        STDERR_FILE=$(mktemp)
        set +e
        OUTPUT=$(goupdate update -r "$RULE" $UPDATE_FLAG $EXCLUDE_FLAG $TEST_FLAG $VERBOSE_FLAG --continue-on-fail -y 2>"$STDERR_FILE")
        EXIT_CODE=$?
        set -e

        # Show any stderr
        if [[ -s "$STDERR_FILE" ]]; then
          cat "$STDERR_FILE" >&2
        fi
        rm -f "$STDERR_FILE"

        # Show output
        echo "$OUTPUT"

        # If command failed and verbose was not enabled, re-run with verbose for debugging
        if [[ "$EXIT_CODE" -ne 0 && "$VERBOSE" != "true" ]]; then
          echo ""
          echo "::group::Re-running with verbose output for debugging"
          echo "Command failed with exit code $EXIT_CODE. Re-running with verbose mode to show detailed failure information..."
          echo ""
          goupdate update -r "$RULE" $UPDATE_FLAG $EXCLUDE_FLAG $TEST_FLAG -v --continue-on-fail -y --dry-run 2>&1 || true
          echo "::endgroup::"
        fi

        # Parse updated packages from output (space-separated)
        # Note: grep returns exit code 1 if no matches, so we use || true to prevent script exit
        UPDATED_PACKAGES=$(echo "$OUTPUT" | grep -E "ðŸŸ¢ Updated" | awk '{print $NF}' | tr '\n' ' ' | sed 's/ $//' || true)
        UPDATED_COUNT=$(echo "$UPDATED_PACKAGES" | wc -w | tr -d ' ')

        # Determine if updates were applied by checking git status
        UPDATED="false"
        if ! git diff --quiet 2>/dev/null; then
          UPDATED="true"
        fi

        echo "updated=$UPDATED" >> "$GITHUB_OUTPUT"
        echo "updated_packages=$UPDATED_PACKAGES" >> "$GITHUB_OUTPUT"
        echo "updated_count=$UPDATED_COUNT" >> "$GITHUB_OUTPUT"
        echo "exit_code=$EXIT_CODE" >> "$GITHUB_OUTPUT"

        # Store output for summaries
        {
          echo "update_output<<EOF"
          echo "$OUTPUT"
          echo "EOF"
        } >> "$GITHUB_OUTPUT"

        if [[ "$EXIT_CODE" -ne 0 ]]; then
          echo "::warning::goupdate update exited with code $EXIT_CODE"
        fi

        exit $EXIT_CODE
