# Goupdate Action
# Consolidated action for Go dependency management using goupdate
# Copy to other projects: .github/actions/_goupdate/
#
# Modes:
#   - check: Only check for updates (no changes)
#   - update: Apply updates without checking first
#   - check-and-update: Check and apply updates (default)
#
# Behavior:
#   - In goupdate repo: Builds from source (dogfooding)
#   - In other repos: Downloads latest release from GitHub
#
# Error Handling:
#   - Uses --continue-on-fail to show all package errors before failing
#   - Captures exit codes from goupdate commands
#   - Step fails with non-zero exit code if any errors occurred
#   - Errors are shown in workflow output before failing
#
# Test Output Behavior:
#   - Test output is captured and only shown when:
#     1. Tests fail (exit code != 0) - always shows output
#     2. verbose: 'true' is set - shows output in collapsible group
#   - For quiet CI runs, use test-command: 'make test-ci' or 'go test -race ./...'

name: 'Goupdate'
description: 'Go dependency management using goupdate (check, update, or both)'

inputs:
  mode:
    description: 'Operation mode: check, update, or check-and-update'
    required: false
    default: 'check-and-update'
  working-directory:
    description: 'Working directory containing go.mod'
    required: false
    default: '.'
  update-type:
    description: 'Type of updates: none (use constraints), patch, minor, or all (includes major)'
    required: false
    default: 'minor'
  test-command:
    description: 'Test command to run after updates (use "skip" to skip)'
    required: false
    default: 'go test -race ./...'
  fail-on-major-only:
    description: 'Exit with error if only major updates available'
    required: false
    default: 'true'
  exclude-packages:
    description: 'Packages to skip (comma-separated)'
    required: false
    default: ''
  commit-changes:
    description: 'Auto-commit after successful update'
    required: false
    default: 'false'
  commit-message:
    description: 'Commit message template (use {packages} for list)'
    required: false
    default: 'chore(deps): update Go dependencies'
  goupdate-version:
    description: 'Version to install (latest, or specific tag). Ignored in goupdate repo.'
    required: false
    default: 'latest'
  github-token:
    description: 'GitHub token for API requests (helps with rate limits)'
    required: false
    default: ''
  system-test-mode:
    description: 'System test run mode: after_each (test after each package), after_all (test once after all), none (skip)'
    required: false
    default: ''
  verbose:
    description: 'Enable verbose output (shows goupdate debug info and test output even on success)'
    required: false
    default: 'false'

outputs:
  # Check outputs
  has-updates:
    description: 'Whether any updates are available'
    value: ${{ steps.check.outputs.has_updates }}
  has-major-only:
    description: 'Whether any packages have ONLY major updates'
    value: ${{ steps.check.outputs.has_major_only }}
  updates-json:
    description: 'Full JSON output from goupdate'
    value: ${{ steps.check.outputs.updates_json }}
  major-count:
    description: 'Count of packages with major updates'
    value: ${{ steps.check.outputs.major_count }}
  minor-count:
    description: 'Count of packages with minor updates'
    value: ${{ steps.check.outputs.minor_count }}
  patch-count:
    description: 'Count of packages with patch updates'
    value: ${{ steps.check.outputs.patch_count }}
  summary:
    description: 'Human-readable summary of updates'
    value: ${{ steps.check.outputs.summary }}
  major-packages:
    description: 'List of packages with major-only updates'
    value: ${{ steps.check.outputs.major_packages }}
  outdated-output:
    description: 'Human-readable table of outdated packages'
    value: ${{ steps.check.outputs.outdated_output }}
  # Update outputs
  update-output:
    description: 'Human-readable output from update operation'
    value: ${{ steps.update.outputs.update_output }}
  updated-count:
    description: 'Number of packages updated'
    value: ${{ steps.update.outputs.updated_count }}
  has-changes:
    description: 'Whether go.mod was modified'
    value: ${{ steps.update.outputs.has_changes }}
  updated-packages:
    description: 'List of updated packages'
    value: ${{ steps.update.outputs.updated_packages }}
  major-only-error:
    description: 'Whether exit was due to major-only updates'
    value: ${{ steps.update.outputs.major_only_error }}
  # Install outputs
  goupdate-version:
    description: 'Installed goupdate version'
    value: ${{ steps.install.outputs.version }}
  goupdate-source:
    description: 'Installation source (local-build or release)'
    value: ${{ steps.install.outputs.source }}

runs:
  using: 'composite'
  steps:
    # ========================================
    # Install goupdate
    # ========================================
    - name: Install goupdate
      id: install
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github-token }}
        VERSION: ${{ inputs.goupdate-version }}
      run: |
        set -e
        INSTALL_DIR="$HOME/.local/bin"
        mkdir -p "$INSTALL_DIR"

        # Check if we're in the goupdate repository itself
        IS_GOUPDATE_REPO="false"
        if [ -f "go.mod" ]; then
          MODULE_NAME=$(head -1 go.mod | awk '{print $2}')
          case "$MODULE_NAME" in
            github.com/user/goupdate|github.com/ajxudir/goupdate)
              IS_GOUPDATE_REPO="true"
              ;;
          esac
        fi

        if [ "$IS_GOUPDATE_REPO" = "true" ]; then
          echo "Detected goupdate repository - building from source..."
          go build -o "$INSTALL_DIR/goupdate" .
          echo "source=local-build" >> $GITHUB_OUTPUT
        else
          echo "External project - downloading goupdate from GitHub releases..."
          OS=$(uname -s | tr '[:upper:]' '[:lower:]')
          ARCH=$(uname -m); case "$ARCH" in x86_64) ARCH=amd64;; aarch64|arm64) ARCH=arm64;; armv7l) ARCH=arm;; esac

          API="https://api.github.com/repos/ajxudir/goupdate/releases"
          AUTH=(); [ -n "$GH_TOKEN" ] && AUTH=(-H "Authorization: token $GH_TOKEN")

          # Get release info (specific version or latest/most recent)
          if [ "$VERSION" != "latest" ]; then
            RELEASE=$(curl -sf "${AUTH[@]}" "$API/tags/$VERSION") || { echo "::error::Release $VERSION not found"; exit 1; }
          else
            RELEASE=$(curl -sf "${AUTH[@]}" "$API/latest" 2>/dev/null) || RELEASE=$(curl -sf "${AUTH[@]}" "$API" | jq '.[0]')
          fi

          TAG=$(echo "$RELEASE" | jq -r '.tag_name')
          [ -z "$TAG" ] || [ "$TAG" = "null" ] && { echo "::error::No releases found"; exit 1; }

          # Find and download asset
          ASSET_URL=$(echo "$RELEASE" | jq -r ".assets[] | select(.name | test(\"goupdate.*${OS}.*${ARCH}\"; \"i\")) | .browser_download_url" | head -1)
          [ -z "$ASSET_URL" ] && { echo "::error::No asset for ${OS}_${ARCH}"; exit 1; }

          echo "Downloading $TAG for ${OS}_${ARCH}..."
          curl -sfL "${AUTH[@]}" "$ASSET_URL" | tar xzf - -C "$INSTALL_DIR" goupdate
          chmod +x "$INSTALL_DIR/goupdate"
          echo "source=release" >> $GITHUB_OUTPUT
        fi

        echo "$INSTALL_DIR" >> $GITHUB_PATH
        VER=$("$INSTALL_DIR/goupdate" version --skip-build-checks 2>/dev/null | head -1 || echo "installed")
        echo "version=$VER" >> $GITHUB_OUTPUT
        echo "Installed: $VER"

    # ========================================
    # Check for updates
    # ========================================
    - name: Check for updates
      id: check
      if: inputs.mode == 'check' || inputs.mode == 'check-and-update'
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        echo "Checking for Go module updates..."

        # Track if any command fails (non-zero exit = errors occurred)
        CHECK_FAILED=false
        CHECK_EXIT_CODE=0

        # Run JSON check - capture stdout (JSON) and stderr (errors) separately
        # Use temp file for stderr to avoid corrupting JSON
        STDERR_FILE=$(mktemp)
        set +e
        JSON_OUTPUT=$(goupdate outdated -r mod -o json --continue-on-fail --skip-build-checks 2>"$STDERR_FILE")
        JSON_EXIT_CODE=$?
        STDERR_CONTENT=$(cat "$STDERR_FILE")
        rm -f "$STDERR_FILE"
        set -e

        # Show any stderr output (warnings/errors)
        if [ -n "$STDERR_CONTENT" ]; then
          echo "$STDERR_CONTENT" >&2
        fi

        # Non-zero exit code means errors occurred (partial or complete failure)
        if [ $JSON_EXIT_CODE -ne 0 ]; then
          echo "::warning::goupdate outdated (JSON) exited with code $JSON_EXIT_CODE"
          CHECK_FAILED=true
          CHECK_EXIT_CODE=$JSON_EXIT_CODE
        fi

        # Validate JSON output
        if ! echo "$JSON_OUTPUT" | jq -e . >/dev/null 2>&1; then
          echo "::warning::Invalid JSON output from goupdate, using empty result"
          JSON_OUTPUT='{"packages":[]}'
        fi

        # Use unique delimiter to avoid collision with content
        echo "updates_json<<GOUPDATE_JSON_EOF_5f8a2b" >> $GITHUB_OUTPUT
        echo "$JSON_OUTPUT" >> $GITHUB_OUTPUT
        echo "GOUPDATE_JSON_EOF_5f8a2b" >> $GITHUB_OUTPUT

        OUTDATED=$(echo "$JSON_OUTPUT" | jq '[.packages[] | select(.status == "Outdated")]')
        OUTDATED_COUNT=$(echo "$OUTDATED" | jq 'length')

        # Run table view for display - capture stdout and stderr separately
        STDERR_FILE=$(mktemp)
        set +e
        TABLE_OUTPUT=$(goupdate outdated -r mod --continue-on-fail --skip-build-checks 2>"$STDERR_FILE")
        TABLE_EXIT_CODE=$?
        TABLE_STDERR=$(cat "$STDERR_FILE")
        rm -f "$STDERR_FILE"
        set -e

        # Combine table output with any stderr for display
        OUTDATED_TABLE="$TABLE_OUTPUT"
        if [ -n "$TABLE_STDERR" ]; then
          OUTDATED_TABLE="$TABLE_OUTPUT"$'\n'"$TABLE_STDERR"
        fi

        if [ $TABLE_EXIT_CODE -ne 0 ]; then
          echo "::warning::goupdate outdated (table) exited with code $TABLE_EXIT_CODE"
          CHECK_FAILED=true
          if [ $CHECK_EXIT_CODE -eq 0 ]; then
            CHECK_EXIT_CODE=$TABLE_EXIT_CODE
          fi
        fi

        # Show table output
        echo "$OUTDATED_TABLE"

        # Save table output for use in summaries
        {
          echo "outdated_output<<GOUPDATE_TABLE_EOF_3c7d9e"
          echo "$OUTDATED_TABLE"
          echo "GOUPDATE_TABLE_EOF_3c7d9e"
        } >> $GITHUB_OUTPUT

        if [ "$OUTDATED_COUNT" -eq 0 ]; then
          echo "No updates available"
          echo "has_updates=false" >> $GITHUB_OUTPUT
          echo "has_major_only=false" >> $GITHUB_OUTPUT
          echo "major_count=0" >> $GITHUB_OUTPUT
          echo "minor_count=0" >> $GITHUB_OUTPUT
          echo "patch_count=0" >> $GITHUB_OUTPUT
          echo "summary=No updates available" >> $GITHUB_OUTPUT
          echo "major_packages=" >> $GITHUB_OUTPUT

          # Fail if there were errors during check (exit code 1 or 2)
          if [ "$CHECK_FAILED" = "true" ]; then
            echo "::error::goupdate check completed with errors (exit code: $CHECK_EXIT_CODE)"
            exit $CHECK_EXIT_CODE
          fi
          exit 0
        fi

        echo "has_updates=true" >> $GITHUB_OUTPUT

        MAJOR_COUNT=$(echo "$OUTDATED" | jq '[.[] | select(.major != "#N/A")] | length')
        MINOR_COUNT=$(echo "$OUTDATED" | jq '[.[] | select(.minor != "#N/A")] | length')
        PATCH_COUNT=$(echo "$OUTDATED" | jq '[.[] | select(.patch != "#N/A")] | length')

        MAJOR_ONLY=$(echo "$OUTDATED" | jq '[.[] | select(.major != "#N/A" and .minor == "#N/A" and .patch == "#N/A")]')
        MAJOR_ONLY_COUNT=$(echo "$MAJOR_ONLY" | jq 'length')
        MAJOR_ONLY_LIST=$(echo "$MAJOR_ONLY" | jq -r '.[].name' | tr '\n' ' ')

        HAS_MAJOR_ONLY="false"
        if [ "$MAJOR_ONLY_COUNT" -gt 0 ]; then
          HAS_MAJOR_ONLY="true"
        fi

        echo "major_count=$MAJOR_COUNT" >> $GITHUB_OUTPUT
        echo "minor_count=$MINOR_COUNT" >> $GITHUB_OUTPUT
        echo "patch_count=$PATCH_COUNT" >> $GITHUB_OUTPUT
        echo "has_major_only=$HAS_MAJOR_ONLY" >> $GITHUB_OUTPUT
        echo "major_packages=$MAJOR_ONLY_LIST" >> $GITHUB_OUTPUT

        SUMMARY="$OUTDATED_COUNT outdated: $MINOR_COUNT minor, $PATCH_COUNT patch"
        if [ "$MAJOR_ONLY_COUNT" -gt 0 ]; then
          SUMMARY="$SUMMARY, $MAJOR_ONLY_COUNT major-only"
        fi
        echo "summary=$SUMMARY" >> $GITHUB_OUTPUT

        echo "=== Update Summary ==="
        echo "$SUMMARY"
        echo ""

        # Fail if there were errors during check
        if [ "$CHECK_FAILED" = "true" ]; then
          echo "::error::goupdate check completed with errors (exit code: $CHECK_EXIT_CODE)"
          exit $CHECK_EXIT_CODE
        fi

    # ========================================
    # Apply updates
    # ========================================
    - name: Apply updates
      id: update
      if: inputs.mode == 'update' || inputs.mode == 'check-and-update'
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      env:
        UPDATE_TYPE: ${{ inputs.update-type }}
        TEST_CMD: ${{ inputs.test-command }}
        FAIL_ON_MAJOR: ${{ inputs.fail-on-major-only }}
        EXCLUDE_PKGS: ${{ inputs.exclude-packages }}
        HAS_UPDATES: ${{ steps.check.outputs.has_updates }}
        MODE: ${{ inputs.mode }}
        SYSTEM_TEST_MODE: ${{ inputs.system-test-mode }}
        VERBOSE: ${{ inputs.verbose }}
      run: |
        # For check-and-update mode, skip if no updates
        if [ "$MODE" = "check-and-update" ] && [ "$HAS_UPDATES" = "false" ]; then
          echo "No updates available, skipping"
          echo "updated_count=0" >> $GITHUB_OUTPUT
          echo "has_changes=false" >> $GITHUB_OUTPUT
          echo "updated_packages=" >> $GITHUB_OUTPUT
          echo "major_only_error=false" >> $GITHUB_OUTPUT
          exit 0
        fi

        echo "Applying updates with goupdate..."
        echo "Update type: $UPDATE_TYPE"

        cp go.mod go.mod.backup
        cp go.sum go.sum.backup

        # Determine update flag based on update type
        # "none" means use package manager constraints (no flag)
        case "$UPDATE_TYPE" in
          "none") FLAG="" ;;
          "patch") FLAG="--patch" ;;
          "minor") FLAG="--minor" ;;
          "all"|"major") FLAG="--major" ;;
          *) FLAG="--minor" ;;
        esac

        # Track if update command fails
        UPDATE_FAILED=false
        UPDATE_EXIT_CODE=0

        # Check for major-only situation (JSON check only, table already shown in check step)
        # Capture stdout and stderr separately to get clean JSON
        STDERR_FILE=$(mktemp)
        set +e
        JSON_OUTPUT=$(goupdate outdated -r mod -o json --continue-on-fail --skip-build-checks 2>"$STDERR_FILE")
        OUTDATED_JSON_EXIT=$?
        rm -f "$STDERR_FILE"
        set -e

        # Validate JSON output
        if ! echo "$JSON_OUTPUT" | jq -e . >/dev/null 2>&1; then
          JSON_OUTPUT='{"packages":[]}'
        fi

        OUTDATED_PKGS=$(echo "$JSON_OUTPUT" | jq '[.packages[] | select(.status == "Outdated")]')
        OUTDATED_COUNT=$(echo "$OUTDATED_PKGS" | jq 'length')

        if [ "$OUTDATED_COUNT" -eq 0 ]; then
          echo "No updates available"
          echo "updated_count=0" >> $GITHUB_OUTPUT
          echo "has_changes=false" >> $GITHUB_OUTPUT
          echo "updated_packages=" >> $GITHUB_OUTPUT
          echo "major_only_error=false" >> $GITHUB_OUTPUT
          echo "update_output=" >> $GITHUB_OUTPUT
          rm -f go.mod.backup go.sum.backup
          exit 0
        fi

        UPDATABLE=$(echo "$OUTDATED_PKGS" | jq '[.[] | select(.minor != "#N/A" or .patch != "#N/A")]')
        UPDATABLE_COUNT=$(echo "$UPDATABLE" | jq 'length')
        MAJOR_ONLY=$(echo "$OUTDATED_PKGS" | jq '[.[] | select(.major != "#N/A" and .minor == "#N/A" and .patch == "#N/A")]')
        MAJOR_ONLY_COUNT=$(echo "$MAJOR_ONLY" | jq 'length')

        if [ "$UPDATABLE_COUNT" -eq 0 ] && [ "$MAJOR_ONLY_COUNT" -gt 0 ]; then
          if [ "$FAIL_ON_MAJOR" = "true" ] && [ "$UPDATE_TYPE" != "all" ] && [ "$UPDATE_TYPE" != "major" ]; then
            echo "::error::Only major updates available - manual review required"
            echo "$MAJOR_ONLY" | jq -r '.[].name' | sed 's/^/  /'
            echo "updated_count=0" >> $GITHUB_OUTPUT
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "updated_packages=" >> $GITHUB_OUTPUT
            echo "major_only_error=true" >> $GITHUB_OUTPUT
            echo "update_output=Major-only updates require manual review" >> $GITHUB_OUTPUT
            rm -f go.mod.backup go.sum.backup
            exit 1
          fi
        fi

        # Build optional flags - always use --continue-on-fail to show all errors
        EXTRA_FLAGS="--continue-on-fail"
        if [ -n "$SYSTEM_TEST_MODE" ]; then
          EXTRA_FLAGS="$EXTRA_FLAGS --system-test-mode $SYSTEM_TEST_MODE"
        fi
        if [ "$VERBOSE" = "true" ]; then
          EXTRA_FLAGS="$EXTRA_FLAGS --verbose"
        fi

        echo "Running: goupdate update -r mod $FLAG -y --skip-build-checks $EXTRA_FLAGS"

        # Run update and capture exit code - don't suppress errors
        set +e
        UPDATE_CMD_OUTPUT=$(goupdate update -r mod $FLAG -y --skip-build-checks $EXTRA_FLAGS 2>&1)
        UPDATE_EXIT_CODE=$?
        set -e

        echo "$UPDATE_CMD_OUTPUT"

        if [ $UPDATE_EXIT_CODE -ne 0 ]; then
          echo "::warning::goupdate update exited with code $UPDATE_EXIT_CODE"
          UPDATE_FAILED=true
        fi

        if diff -q go.mod go.mod.backup > /dev/null 2>&1; then
          echo "No changes made"
          echo "updated_count=0" >> $GITHUB_OUTPUT
          echo "has_changes=false" >> $GITHUB_OUTPUT
          echo "updated_packages=" >> $GITHUB_OUTPUT
          echo "major_only_error=false" >> $GITHUB_OUTPUT
          {
            echo "update_output<<GOUPDATE_UPDATE_EOF_8b4f1d"
            echo "$UPDATE_CMD_OUTPUT"
            echo "GOUPDATE_UPDATE_EOF_8b4f1d"
          } >> $GITHUB_OUTPUT
          rm -f go.mod.backup go.sum.backup

          # Fail if update command had errors
          if [ "$UPDATE_FAILED" = "true" ]; then
            echo "::error::goupdate update completed with errors (exit code: $UPDATE_EXIT_CODE)"
            exit $UPDATE_EXIT_CODE
          fi
          exit 0
        fi

        echo "has_changes=true" >> $GITHUB_OUTPUT
        echo "major_only_error=false" >> $GITHUB_OUTPUT

        # Count updated packages (sanitize to ensure single integer value)
        # Using printf to strip any trailing newlines and validate it's a number
        RAW_COUNT=$(diff go.mod go.mod.backup 2>/dev/null | grep "^<" | grep -v "^< //" | wc -l | tr -d ' \n' || true)
        UPDATED_LINES="${RAW_COUNT:-0}"
        # Validate it's a number, default to 0 if not
        if ! [[ "$UPDATED_LINES" =~ ^[0-9]+$ ]]; then
          UPDATED_LINES="0"
        fi
        echo "updated_count=$UPDATED_LINES" >> $GITHUB_OUTPUT

        # Extract package names (sanitize to ensure single line)
        UPDATED_PKGS=$(diff go.mod go.mod.backup 2>/dev/null | grep "^<" | grep -v "^< //" | awk '{print $2}' | tr '\n' ' ' | tr -d '\r' || echo "")
        echo "updated_packages=$UPDATED_PKGS" >> $GITHUB_OUTPUT

        if [ "$TEST_CMD" != "skip" ]; then
          echo ""
          echo "Running tests: $TEST_CMD"

          # Capture test output to only show on failure or when verbose
          TEST_OUTPUT_FILE=$(mktemp)
          TEST_EXIT_CODE=0
          eval "$TEST_CMD" > "$TEST_OUTPUT_FILE" 2>&1 || TEST_EXIT_CODE=$?

          if [ "$TEST_EXIT_CODE" -ne 0 ]; then
            echo "::group::Test Output (failed)"
            cat "$TEST_OUTPUT_FILE"
            echo "::endgroup::"
            echo "::error::Tests failed after updates - rolling back"
            cp go.mod.backup go.mod
            cp go.sum.backup go.sum
            echo "has_changes=false" >> $GITHUB_OUTPUT
            rm -f go.mod.backup go.sum.backup "$TEST_OUTPUT_FILE"
            exit 1
          elif [ "$VERBOSE" = "true" ]; then
            echo "::group::Test Output (verbose)"
            cat "$TEST_OUTPUT_FILE"
            echo "::endgroup::"
          fi

          rm -f "$TEST_OUTPUT_FILE"
          echo "Tests passed!"
        fi

        rm -f go.mod.backup go.sum.backup

        echo ""
        echo "=== Update Complete ==="
        echo "Updated $UPDATED_LINES packages"

        # Save raw goupdate output for summaries
        {
          echo "update_output<<GOUPDATE_UPDATE_EOF_8b4f1d"
          echo "$UPDATE_CMD_OUTPUT"
          echo "GOUPDATE_UPDATE_EOF_8b4f1d"
        } >> $GITHUB_OUTPUT

        # Fail if update command had errors (after saving output for visibility)
        if [ "$UPDATE_FAILED" = "true" ]; then
          echo "::error::goupdate update completed with errors (exit code: $UPDATE_EXIT_CODE)"
          exit $UPDATE_EXIT_CODE
        fi

    # ========================================
    # Commit changes (optional)
    # ========================================
    - name: Commit changes
      if: inputs.commit-changes == 'true' && steps.update.outputs.has_changes == 'true'
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      env:
        COMMIT_MSG: ${{ inputs.commit-message }}
        UPDATED_PKGS: ${{ steps.update.outputs.updated_packages }}
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"

        # Replace {packages} placeholder if present
        FINAL_MSG=$(echo "$COMMIT_MSG" | sed "s/{packages}/$UPDATED_PKGS/g")

        git add go.mod go.sum
        git commit -m "$FINAL_MSG"
        echo "Committed changes with message: $FINAL_MSG"
